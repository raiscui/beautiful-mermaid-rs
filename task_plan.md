# 任务计划: ASCII/Unicode 输出可读性改良(续)

> 续档说明:
> - 旧 `task_plan.md` 已超过 1000 行,按约定已归档为: `task_plan_2026-02-09.md`
> - 本文件从 2026-02-09 起继续记录后续计划与进展

## 目标
把用户复现图在 `beautiful-mermaid-rs --ascii`(Unicode box-drawing) 下的输出,从“能渲染”提升到“人类可读”:

- 边从 box 最近侧边出/入线,避免“背向端口”导致的大外圈绕行
- 尽量避免把线画到画布最外圈形成“外框”
- 尽量避免 `┬/┴/├/┤/┼` 造成的误连线错觉
- 在不牺牲 CLI 性能的前提下(QuickJS 无 JIT),保持结果稳定可回归(有测试兜底)

## 阶段
- [x] 阶段1: 复现与量化指标
- [x] 阶段2: 方案设计(两条路线)
- [x] 阶段3: 落地实现(优先改良,少新增)
- [x] 阶段4: 测试与验收(含 golden 更新)
- [x] 阶段5: 记录沉淀(四文件 + continuous-learning)

## 关键问题
1. “糟糕”的根因是哪一类?
   - 当前判断: 主要是 **backward edge(在 TD 下向上走的边)** 被错误地选到“背向端口”,从而被迫绕外圈。
2. 我们是否允许改变上游 TS baseline?
   - 允许。因为现在输出已回到 TS 基线,但用户仍不满意,下一步必然是“改良算法”,同步 vendor 并更新 golden。

## 两种实现路线(需要先定,避免反复摇摆)
1. 路线A(不惜代价/最佳方案,推荐): 改良 relaxed 路由策略,让候选端口组合更贴近“最近侧边”直觉
   - 核心动作(优先低风险项):
     - relaxed 候选集增加“朝向过滤”: 能不背向就绝不背向(必要时再降级)
     - relaxed backward edge 端口组合改良: 允许 Up/Down/Left/Right 组合,避免被固定到 Right 侧
     - 只在必要时再考虑: 调整 edge routing 顺序(确定性排序),降低“最后一条边被挤到外圈”的概率
   - 代价: 需要同步 vendor bundle,并更新部分 golden

2. 路线B(先能用/后面再优雅): 增加 CLI 级别的“可读性开关”
   - 例: `--hide-edge-labels` / `--compact-labels(编号+legend)` / `--routing=relaxed|strict`
   - 优点: 用户可立即通过参数选出更可读的版本
   - 缺点: 这是新增功能面,需要文档+更多测试,且会分散主线精力

## 做出的决定
- [决定] 先走路线A 的“朝向过滤 + backward 端口组合改良”。
  - 理由: 属于算法层面的改良,不引入新 CLI 面,也更符合你强调的“改良胜过新增”。

## 状态
**已完成阶段5** - 变更已沉淀到四文件,并且 `cargo test --release` 通过。

## 进展日志

### 2026-02-09 16:19:24 - 阶段1: 复现与量化(进行中)

- 我为什么先做这个:
  - 你现在说“结果还是很糟糕”,这已经不是“测试不通过”的问题,而是“审美/可读性”问题。
  - 不把问题量化成可回归的指标,后面只能靠感觉盲调,很容易越修越乱。
- 我做了什么:
  - 复现你的原始 Mermaid(用 heredoc 保证输入干净):
    - `cat <<'EOF' | beautiful-mermaid-rs --ascii ... EOF`
  - 用 `cargo run --release --example debug_user_case_meta` 打印 meta:
    - 读取 node box(x,y,width,height)
    - 读取每条 edge 的 `path.first()/path.last()` 坐标
- 关键证据(定量):
  - 节点布局呈“两列极端分离”:
    - 左列: Start/Hat_ralph/Hat_experiment_runner/Complete
    - 右列: Hat_experiment_integrator/Hat_experiment_auditor
  - 多条 backward edge(在 TD 下向上走)出现“背向端口”:
    - 例如 `Hat_experiment_integrator -> Hat_ralph (integration.rejected)`:
      - `first.x=99`(贴着 integrator 的右侧边),而 ralph 在左侧
      - `last.x=6`(贴着 ralph 的左侧边),而 integrator 在右侧
    - 这会直接导致你看到的“绕外圈画大框”。
- 下一步(进入阶段2/3):
  - 路线A 的最小改良落点:
    1) relaxed 候选端口做“朝向过滤”(能不背向就不背向,无可用候选再降级)
    2) relaxed backward edge 的 base 候选对(Up/Down/Left/Right)改为按 dx/dy 生成,避免被固定到 Right 侧

### 2026-02-09 16:35:40 - 阶段3/4: 采用“双向边下沉布局”消除外圈绕行(已完成)

- 我为什么改布局,而不是继续硬调 A*:
  - 复现图的本质是“同一父节点的多个 child 横向铺开 + 存在双向边”,导致 backward edge 很长,
    在“不共线重叠”的规则下容易被挤到外圈。
  - 继续加惩罚项只能让 A* 更难选,但不解决“几何结构”本身的问题。
- 我做了什么(上游 TS):
  - `src/ascii/grid.ts`:
    - 在 TD + Unicode relaxed 下,如果 parent 与 child 存在反向边(child->parent),
      则把该 child 下沉到下一层(childLevel + gridStep),并优先与 parent 对齐同一列(x=parent.x)。
    - 目标是把双向关系从“左右跨列”变成“垂直回路”,显著减少外圈绕行。
  - 同步 bundle 到本仓库 vendor:
    - `vendor/beautiful-mermaid/beautiful-mermaid.browser.global.js`
- Rust 侧回归更新:
  - `tests/ascii_endpoint_alignment.rs`:
    - 右侧贴边样例从 `experiment.complete` 调整为 `integration.blocked`(布局变化后更稳定)。
  - `tests/testdata/unicode/user_repro_case.txt`:
    - 更新 golden,锁死新布局输出(更可读版本)。
- 验证:
  - `cargo test --release` ✅ 全绿
  - `make install INSTALL_DIR=/Users/cuiluming/local_doc/l_dev/tool` ✅ 已覆盖安装最新 CLI
  - 复现你的命令: 输出不再画巨大外圈,节点更集中,边更短(可读性显著提升)。

### 2026-02-09 16:57:10 - 用户再次反馈“结果还是很糟糕”: 重新定位 label 扩列导致的画布膨胀(进行中)

- 我正在做什么,为什么:
  - 我先用当前已安装的 `beautiful-mermaid-rs` 复现你的命令,把“糟糕”落到可观察的形态(外框/空白/宽度)。
  - 复现输出里最显眼的问题不是“渲染失败”,而是“画布被拉得过宽 + 某些边被迫绕外圈”。
  - 我怀疑根因在 label 布局策略: 当前实现会在选定 `labelLine` 后,
    **无条件**把某一整列 `columnWidth` 拉到 `labelWidth+2`,
    即使该线段的“总宽度”本来已经足够放下 label。
  - 这会直接制造大量空白,也会放大 detour 的视觉成本,让边更像是在画“外框”。
- 我准备怎么改(优先改良,不新增 CLI 开关):
  1) 在上游 TS `determineLabelLine()` 里,把“无条件扩到 `labelWidth+2`”改成:
     - 只在当前线段总宽度不足时,按缺口做**最小增量**扩列。
  2) 保持 label 不裁剪(可逆自证不变),但显著减少无意义空白与外框概率。
- 验证计划:
  - 复现图输出: 宽度收敛,外框收敛,边更短更集中。
  - `scripts/sync-vendor-bundle.sh` 同步 bundle 后,跑 `cargo test --release` 确保回归全绿。

### 2026-02-09 17:12:40 - 继续改良: 路由顺序对“平行边/回边”可读性的决定性影响(准备实施)

- 我正在做什么,为什么:
  - 复现图里,`Hat_ralph -> Hat_experiment_integrator (integration.task)` 是一条“顺着 TD 向下走”的主干边,
    但在 Mermaid 文本里它出现在最后,导致当前实现按 insertion order 路由时,
    主干通道先被多条“向上回边”(integrator->ralph)占掉,主干边被迫走外圈画矩形。
  - 这类问题的本质不是 A* 算法不行,而是“先画谁”决定了通道占用:
    在我们仍然使用 hard rule 禁止 segment overlap 的前提下,路由顺序就是一等公民。
- 我准备怎么改(仍然不新增 CLI 开关,且只在 Unicode relaxed 启用以控影响面):
  1) `src/ascii/grid.ts` 路由阶段引入一个**稳定分区**顺序:
     - 先路由“顺着图方向”的 forward edges(TD: dy>0, LR: dx>0),
     - 再路由 neutral edges,
     - 最后路由 backward edges。
  2) 这样主干边更容易拿到直通路径,回边再选择 detour,整体更像人画的流程图。
- 验证计划:
  - 重点看复现图: `integration.task` 是否能从“大矩形”收敛为更短更直的通路。
  - 跑 `cargo test --release` 看 golden 漂移范围(预计只影响少量 Unicode relaxed 用例)。

### 2026-02-09 17:23:30 - 校准方案: 全局 forward-first 影响面过大,改为“仅延后回边”(准备实施)

- 我正在做什么,为什么:
  - 我刚才尝试了“全局 forward-first”分区路由,确实能让某些主干边更直,
    但副作用非常大: 其它边的通道占用被整体打散,复现图反而出现更大的外框/更宽的画布,甚至有 label 贴到 box 边框的风险。
  - 这说明“全局排序”太粗暴,会把局部问题扩散成全局扰动。
- 新策略(更小的手术刀):
  - 不把 forward edge 提到最前面。
  - 只做一件事: **当一条 backward edge 的反向边(forward)在输入顺序里更靠后时,延后这条 backward edge 的路由**。
  - 这样可以保证“先画主干,再画回边”,但不会打乱其它无关边的顺序。
- 验证计划:
  - 复现图重点看: `integration.task` 是否摆脱外圈大矩形,同时不引入新的大范围 detour。
  - 如 golden 漂移过大,立刻回滚该排序改动,只保留前一轮的 label 扩列改良。

### 2026-02-09 17:30:50 - 结论: “改路由顺序”会把局部问题扩散成全局外框,决定回滚

- 我观察到的现象:
  - 不论是全局 forward-first,还是“延后回边”,都会让复现图出现更大的外框矩形(甚至跑到 Start 上方),
    并且更容易出现 edge label 贴近/覆盖 box 边框的风险。
  - 这说明在当前 hard rule(禁止 segment overlap)框架下,单纯调换“先画谁”只是把痛点从一条边转移到另一条边,
    并不能降低整体 detour 的上限。
- 决策:
  - **回滚**所有“路由顺序”相关改动,恢复 insertion order。
  - 保留上一轮已经验证有效且影响面可控的改良: `determineLabelLine()` 的“最小增量扩列”。
- 下一步:
  - 在不改路由顺序的前提下,继续从“减少外圈 detour 的成本函数/约束”或“多边同端点的呈现策略”入手迭代。

### 2026-02-09 18:12:10 - 用户反馈: 依然很乱(合并线太多),要求“回滚重做方案”(进行中)

- 我正在做什么,为什么:
  - 你反馈的核心不是“渲染失败”,而是“人类读不懂逻辑关系”。
  - 这类问题通常有两层原因:
    1) 渲染器算法回归(同一张图,输出比以前更差)。
    2) 图本身是“多入边汇聚到单点”的结构,哪怕算法没回归,在终端 ASCII/Unicode 里也天然容易变成“线团”。
  - 所以我先把问题拆成两条线并行推进,避免再次盲调:
    - 线1: 用当前工作区版本复现你的 Mermaid,确认是否真的存在“回归”。
    - 线2: 给出“终端可读”的 Mermaid 写法(不新增 CLI 开关),把逻辑关系表达得更清晰。

- 两种方案方向(先写清楚,避免反复摇摆):
  1) 方向A(不惜代价/最佳方案,推荐): 把你的 flowchart 改写为更适合“多消息往返”的 `sequenceDiagram`
     - 目标: 用“参与者泳道 + 消息箭头”消除大量合并线,让终端输出天然更清爽。
     - 特点: 不需要改渲染器算法,也不需要新增 CLI 参数,只改 Mermaid 表达方式。
  2) 方向B(先能用/后面再优雅): 继续改良 flowchart 的走线策略,专门优化“多入边汇聚”类图
     - 可能手段:
       - 同一 target 的多条边,在 target 附近自动“分层进入”(减少同一 cell 的多重 junction)
       - 对“密集汇聚区”引入轻量级虚拟汇聚点(内部节点,不改语义),让线先汇聚再进 box
     - 风险: 算法改动影响面更大,需要更多 golden 更新与回归验证。

- 下一步(先做最小可验证闭环):
  1) 在本仓库里复现你给的 flowchart TD 输入,把当前 `--ascii` 输出保存为证据。
  2) 我会把同一逻辑改写成 `sequenceDiagram`,并用 `beautiful-mermaid-rs --ascii` 输出对比,确认是否达到“终端可读”。
  3) 如果 sequenceDiagram 明显更好,我们就把它沉淀成 `docs/terminal-readable-diagrams.md` 的推荐模板与示例。
  4) 如果 sequenceDiagram 仍然不够清晰,再回到方向B,做渲染器层面的改良与测试兜底。

### 2026-02-09 18:33:05 - 用户决定: 坚持一定要 flowchart(进入方向B)(进行中)

- 我正在做什么,为什么:
  - 你明确要求必须是 flowchart,这意味着我们不能靠“换图类型”来绕开物理限制。
  - 但我们仍然可以通过渲染器内部的“结构化改良”,把最糟糕的线团压下去:
    - 典型目标: 针对“同一对节点之间的多条带 label 的边”和“多入边汇聚到单点”的场景,减少外圈绕行与 `┼` 密度。
  - 我会优先选择“改良胜过新增”的手段:
    - 不新增 CLI 开关。
    - 尽量让改动只影响明确的病灶场景(多边汇聚),避免波及所有用例。

- 方案方向(两条,需要择一落地;我会先做风险更小的):
  1) 方案B1(优先落地/风险更小): 多重边(同 from/to)的“共享干线 + 分离 label”
     - 思路:
       - 多条边如果端点相同,允许它们共享一条 route(避免重复占用通道,减少 junction)。
       - label 不再强行挤到同一段线上,而是在干线附近做“纵向堆叠”(每条边一行),保持每个 label 仍然可见且短。
     - 优点: 不改变语义(仍然是多条边),只是路由/标注更聪明。
     - 风险: 需要动到 label 绘制/占位逻辑,要小心不把 node port 语义搞乱。

  2) 方案B2(备选/更激进): 在目标节点附近引入“虚拟汇聚点”(内部实现,不改变输入)
     - 思路:
       - 对入边过多的 target,在其附近找一个空白 cell 作为 hub,
         让多条边先汇聚到 hub,再用一条短边进 box。
     - 优点: 结构上最像人手画的“总线/汇聚”。
     - 风险: 需要引入新的布局约束,影响面更大。

- 我接下来会怎么做(可验证闭环):
  1) 在 TS 上游仓库里定位 flowchart ASCII/Unicode 的 edge routing + label placement 代码位置。
  2) 先实现 B1 的最小版本(只对同端点 multi-edge 启用),并用你的复现图做对照。
  3) 同步 vendor bundle 到本仓库,更新必要的 golden,补充一个“线团度量”的回归测试(比如 junction 数量阈值/画布宽度阈值)。
  4) `cargo test --release` 全绿后,再把新的终端输出贴给你确认是否达到“可读”。

### 2026-02-09 19:12:31 - 复现确认: “主干边最后路由”会把边挤成外框(进行中)

- 我正在做什么,为什么:
  - 你现在的反馈点很明确: 依然很乱,而且合并线太多,终端读不懂。
  - 我先用当前工作区版本严格复现你给的 Mermaid,避免“靠感觉”改一堆算法后仍然不对。
  - 复现的目的不是证明“能不能渲染”,而是定位哪一条边在制造最强的阅读噪声(典型就是外框)。

- 复现证据(当前实现,输入顺序不变):
  - `Hat_ralph -->|integration.task| Hat_experiment_integrator` 这条边因为出现在 Mermaid 文本最后,
    会在其它边已经占满通道后才开始路由,最终被迫绕到最外圈,形成一个看起来像“subgraph 外框”的大矩形。
  - 我把同一份 Mermaid 仅做“行顺序调整”(把 `integration.task` 提前),终端输出立刻收敛,
    说明这不是“画不出来”,而是“路由顺序在 hard rule 下决定了可读性”。

- 决策(回滚重做方案,不新增 CLI 开关):
  1) 放弃“让平行边共享干线”作为主线解法(它会让语义更难追踪,且对外框问题帮助有限)。
  2) 改为更贴近人类画图直觉的策略: **生成树主干边优先路由**。
     - 先把“把节点连起来的主干边”(覆盖所有节点的 spanning forest)路由出来,让主干尽量直、短、在内圈。
     - 再路由回边/补充边(例如多条结果回到协调者),允许它们为避让主干而绕一点。
  3) 这类改良不需要任何新参数,但会改变输出,因此要同步 vendor 并更新 golden,用测试锁死回归。

- 下一步(可验证闭环):
  - 在 TS 上游的 `src/ascii/grid.ts` 实现“spanning forest 优先”的 `edgesForRouting` 排序(仅对 Unicode relaxed 启用以控影响面)。
  - 同步 vendor bundle 回本仓库,跑 `cargo test --release`,必要时更新 golden。

### 2026-02-09 19:18:03 - 已落地: 生成树主干边优先路由,外框消失(已验证)

- 我做了什么(不新增 CLI 开关):
  - 上游 TS: `src/ascii/grid.ts` 把 `edgesForRouting` 从“严格按输入顺序”调整为:
    - Unicode + relaxed 下,先路由 spanning forest 的主干边,再路由剩余边(其余模式保持原样)。
  - Rust: 同步 vendor bundle,并更新 Unicode golden:
    - `tests/testdata/unicode/user_repro_case.txt`
  - Rust 测试加固:
    - `tests/ascii_endpoint_alignment.rs` 去掉“某条边必须从右侧进入”的不稳定断言,保留真正不变量: 所有入边箭头必须贴边。

- 为什么这样改能解决你看到的“外框 + 线团”:
  - 主干边(例如 `integration.task`)被提前路由后,会占住“最直/最短/最内圈”的通道,
    后续回边再做避让,就不会把整张图绕成一个大矩形外框。

- 验证:
  - 复现命令(与你一致):
    - `printf 'flowchart TD ...' | beautiful-mermaid-rs --ascii`
    - 现在 `integration.task` 不再画出顶层大矩形外框,整体收敛到内圈。
  - `cargo test --release` ✅
  - `make install` ✅ 已更新 `/Users/cuiluming/local_doc/l_dev/tool/beautiful-mermaid-rs`

### 2026-02-09 20:45:00 - 分析 `integration.blocked` 视觉多线段问题(进行中)

- 目标:
  - 解释为什么 `integration.blocked` 在语义上是一条边,但在 Unicode 图里看起来像多条线段。
  - 评估当前路由是否还有可继续优化的算法方向。

- 阶段:
  - [x] 阶段1: 复盘历史上下文与已有修复记录
  - [x] 阶段2: 读取当前走线实现并确认根因
  - [x] 阶段3: 给出可落地的优化方向和取舍
  - [x] 阶段4: 同步记录与对外说明

- 当前状态:
  - 已完成根因确认: 视觉“多线段”不是 `integration.blocked` 单边异常,而是 4 条 `Hat_experiment_integrator -> Hat_ralph` 平行边叠加 + comb ports 分 lane 的合成效果。
  - 已确认当前路由默认是 Unicode relaxed,会启用 spanning-forest-first 排序与终点段复用优先,因此平行边会尽量靠近主干走,更容易在视觉上形成“线束”。
  - 下一步如需继续优化,可走两条路线:
    - 最佳方案: 同端点多边做 bundle trunk + endpoint fanout 的分组路由,把“主干+分叉”作为一等对象优化。
    - 渐进方案: 增加多边密度惩罚和标签避让二次 reroute,先降低右侧聚团感,保持兼容性。

### 2026-02-09 21:08:00 - 执行用户选择: 最佳方案(进行中)

- 用户决策:
  - 采用“最佳方案”。
  - 同时要求 label 支持上下堆叠,不要水平拼接在一起。

- 实施阶段:
  - [x] 阶段1: 在 TS 上游实现 bundle trunk 路由(同 from/to 多边共主干)
  - [x] 阶段2: 在绘制层实现 bundle label 纵向堆叠(避免横向拼接)
  - [x] 阶段3: 同步 vendor 到 Rust 仓库并更新必要 golden
  - [x] 阶段4: 跑测试并回归复现图验证

- 当前状态:
  - 已完成最佳方案落地并通过 Rust 全量测试:
    - `cargo test` 全部通过。
  - 用户复现图验证完成:
    - 同端点多边现在共享主干,标签按纵向堆叠展示,不再横向拼接。
  - 过程中顺手修复了上游 TS 的运行时错误:
    - `src/ascii/pathfinder.ts` 中 `segmentPairMulti` / `segmentPair` 局部变量缺失导致 relaxed 路由 ReferenceError。

### 2026-02-09 21:41:00 - 持续优化: “左侧更近却走右侧”问题(进行中)

- 用户新反馈:
  - 某些绕路线路明明 box 左边更近,但最终走了右边。

- 根因预判:
  - 当前 relaxed 在“同 target 终点段复用”下,会偏向复用已存在的入边侧;
  - 当该侧已有边(例如 `experiment.reviewed` 先占右侧)时,后续边容易被吸附到同侧,即使另一侧更空更近。

- 本轮计划:
  - [ ] 阶段1: 增加“目标侧拥挤惩罚”并只在垂直主导场景启用
  - [ ] 阶段2: 复现图验证是否改为更近侧入边
  - [ ] 阶段3: 回归测试与 golden 稳定性检查

- 当前状态:
  - 即将开始阶段1,先在 `edge-routing.ts` 的 relaxed 候选打分里加入轻量侧拥挤项,避免大范围行为漂移。

### 2026-02-10 00:00:00 - 继续执行未完成步骤: “左侧更近却走右侧”优化(进行中)

- 我正在做什么,为什么:
  - 我先接着上一次未完成的阶段继续,不重新开题,避免重复试错。
  - 先核查 `edge-routing.ts` 的实验性 fast-probe 改动是否稳定,因为这段直接影响候选选择与可读性回归。
  - 这一步的目标是回到“可解释、可验证”的基线,再做定向优化,而不是在不稳定状态上继续叠加补丁。

- 本轮两种实现方向(先写清楚):
  1) 最佳方案(当前执行): 候选恢复 + 左侧可达优先
     - 在垂直主导且存在回边的场景,强制补探一次 endDir 扩展候选。
     - 若 `end=Left` 可达且总成本不显著更差,优先左入,减少远绕。
  2) 渐进方案: 仅调惩罚权重
     - 继续增大侧拥挤惩罚或 detour 惩罚,尝试把路径压回近侧。
     - 风险是“不可达候选”问题不解决,容易出现调参震荡。

- 决策:
  - 继续执行最佳方案,因为用户已明确选择“最佳方案”,且该问题根因是可达性受限而不是单纯惩罚不足。

- 下一步:
  - 先清理或收敛 `shouldProbeExpandedAllFast` 实验逻辑。
  - 然后实现“左侧可达优先”的定向选择规则,并进行复现与测试验证。

### 2026-02-10 00:08:00 - 定位阶段: 先验证“终点段复用优先”是否把路径吸附到右侧(进行中)

- 我正在做什么,为什么:
  - 复现输出显示 `Hat_experiment_integrator -> Hat_ralph` 4 条边都固定为 `start=(Left), end=(Right)`。
  - 这说明不是单条边随机漂移,而是候选选择策略存在系统性偏向。
  - 我先做小步实验验证: 调整 `allowEndSegmentReuse` 的尝试顺序,确认右侧吸附是否由“复用优先”触发。

- 预期:
  - 如果顺序调整后出现左入或下入,说明根因主要在“复用优先”策略。
  - 若仍无变化,再进入“可达性候选恢复”方案。

### 2026-02-10 00:16:00 - 定向改良实施: 增加“垂直主导下横向跨侧”惩罚,抑制左右对穿大回环(准备实施)

- 我正在做什么,为什么:
  - 实验确认: 仅调整复用顺序会把路径从“右入”切到“左入”,但可能触发更大的顶边绕行。
  - 根因更像是“候选代价函数没有把左右对穿当成坏味道”,导致首条平行边选错侧后,后续同 pair 全部被绑定。

- 这一步怎么改:
  - 在 `nearestSidePenaltyRelaxed` 里新增一个极窄触发条件:
    - 垂直主导 + x 方向几乎重叠 + start/end 都是水平端口且左右对穿。
  - 满足时加高额惩罚,让算法优先选“同侧或竖向进入”的候选。

- 预期:
  - 复现图中 `Hat_experiment_integrator -> Hat_ralph` 不再稳定走“左出右入”的对穿路径。

### 2026-02-10 00:23:00 - 深入诊断: 采集候选可达性与成本证据(进行中)

- 我正在做什么,为什么:
  - 单纯加惩罚后路径虽改成左入,但出现更大顶边绕行,说明我们需要精确看到每个候选的“可达/不可达 + 成本”。
  - 我将做一次临时调试打印,只针对 `Hat_experiment_integrator -> Hat_ralph` 这组边输出候选信息,定位真正可选空间。

- 目标:
  - 找到“近路没被选中”究竟是不可达还是被打分压过。

### 2026-02-10 00:38:00 - 回滚局部重排实验,改为“双策略对比”稳态优化(进行中)

- 我正在做什么,为什么:
  - 我验证了“反向多边优先重排”后,复现图整体可读性明显下降(标签和路径冲突增加),副作用不可接受。
  - 因此已回滚 `grid.ts` 该实验,避免把局部问题扩散到全局。

- 新策略:
  - 保持当前路由顺序不动。
  - 在 `edge-routing.ts` 里同时计算 `allowEndReuse=false/true` 两种 relaxed 结果并做质量对比。
  - 当“非复用方案能消除左右对穿且成本/长度只略差”时,优先非复用;否则保持现状。

- 目标:
  - 解决“左侧更近却没走左侧”的可感知问题,同时避免再次出现全局布局退化。

### 2026-02-10 00:58:00 - 本轮收口: 阶段完成状态更新

- 本轮阶段清单(对应“左侧更近却没走左侧”继续优化):
  - [x] 阶段1: 核查并清理实验性改动
  - [x] 阶段2: 实现可达性优先的候选比较策略
  - [x] 阶段3: 同步 vendor 与必要 golden
  - [x] 阶段4: 测试与复现验证

- 验证结果:
  - `cargo test --test ascii_testdata unicode_testdata_matches_reference --quiet` 通过。
  - `cargo test --test ascii_user_case_edge_endpoint_invariants --quiet` 通过。
  - `cargo test --quiet` 全量通过。
  - `make install INSTALL_DIR=/Users/cuiluming/local_doc/l_dev/tool` 安装完成。

- 当前状态:
  - **阶段4已完成** - 已进入交付说明与后续建议阶段。

### 2026-02-10 01:10:00 - 新反馈继续优化: 并线注释必须上下排列(进行中)

- 我正在做什么,为什么:
  - 你指出“并线注释很乱,必须上下排列,不能左右拼在一起”,这说明当前标签分组的覆盖范围还不够。
  - 我会先做最小可复现定位,确认哪些并线关系没有被现有 bundle-label 逻辑捕获。

- 本轮两种实现方向(先明确):
  1) 最佳方案(当前执行): 按“共享主干线段”分组后统一纵向堆叠
     - 不再只按同 from/to 分组,而是按真实路径重叠关系分组。
     - 组内强制同 x 锚点,按 y 分层,杜绝左右并排。
  2) 渐进方案: 仅加标签碰撞后避让
     - 保留现分组,在绘制前做 bbox 碰撞检测,冲突时局部下移。
     - 优点快,但无法从根上禁止“左右拼接”。

- 决策:
  - 先执行最佳方案,因为你的约束是硬要求(不能左右排列),而不是“尽量”。

- 下一步:
  - 读取 `draw.ts` 现有 bundle 标签逻辑与 anchor/rank 规则。
  - 做并线分组扩展并加测试验证。

### 2026-02-10 01:18:00 - 进入实现: 并线标签禁用横向漂移,仅允许纵向避让(准备实施)

- 我正在做什么,为什么:
  - 已定位到 `drawTextOnLine()` 在 `baseCanvasForAvoid` 分支里优先做 `startX` 搜索,这是“左右并排”的直接来源。
  - 对并线标签来说,你的规则是硬约束: 只能上下堆叠,不能左右展开。

- 实施点:
  - 在 `drawTextOnLine` 增加“仅纵向避让”模式。
  - 在 Unicode relaxed + bundle 标签路径中开启该模式。

- 预期:
  - 并线标签保持同一中心 x,冲突时只上下找位。

### 2026-02-10 01:24:00 - 已完成实现: 并线标签进入“仅纵向避让”模式

- 已改动:
  - `src/ascii/draw.ts`
    - 新增 `DrawTextOnLineOptions.verticalOnlyStack`。
    - `verticalOnlyStack=true` 时,标签中心 x 固定,冲突只做 y 轴搜索。
    - Unicode relaxed 下无合法位则不绘制,避免横向拼接成串。
  - 在 `drawGraph()` 的 Unicode relaxed 顺序绘制里:
    - 对 bundle 分组标签自动启用 `verticalOnlyStack`。

- 这样做的意义:
  - 从机制上禁止并线标签左右扩散,满足“只能上下排列”的硬约束。

### 2026-02-10 01:34:00 - 本轮收口: 并线标签仅纵向堆叠已完成

- 本轮阶段清单:
  - [x] 阶段1: 追加记录新一轮任务计划
  - [x] 阶段2: 定位并线标签布局根因
  - [x] 阶段3: 实现强制纵向堆叠策略
  - [x] 阶段4: 同步 vendor 与安装
  - [x] 阶段5: 测试验证

- 当前状态:
  - **本轮已完成** - 已满足“并线注释上下排列,不左右排列”的实现约束。

### 2026-02-10 01:43:00 - 二次修正: 同组标签统一中心 x(进行中)

- 我正在做什么,为什么:
  - 通过坐标定位确认: 之前仅共享 y,不同标签仍按各自 labelLine 取中心 x,导致左右散开。
  - 已在 `buildBundleStackedLabelLines()` 把同组标签改为共享 `anchorCenterX`(中位数中心),从根上消除横向离散。

- 下一步:
  - 复现用户图验证这 4 个并线标签是否收敛为同一垂直列。
  - 同步 vendor 并跑测试。

### 2026-02-10 01:55:00 - 本轮最终收口: 同组标签共享 x+y 轴策略已完成

- 本轮补充阶段:
  - [x] 阶段6: 根因复盘(只共享 y 导致横向离散)
  - [x] 阶段7: 实施同组共享 center x
  - [x] 阶段8: 同步 vendor + 更新 golden + 验证

- 结果:
  - 并线标签从横向分散收敛为同列纵向堆叠,满足用户硬约束。

### 2026-02-10 02:10:00 - 用户确认继续: 增强并线标签可辨识度(进行中)

- 我正在做什么,为什么:
  - 你确认要继续,当前虽然标签已纵向堆叠,但“属于哪条线”在密集区域仍不够直观。
  - 本轮在不破坏既有布局的前提下,增加一个极短“贴线引导符”,帮助视觉追踪。

- 本轮两种方向:
  1) 最佳方案(当前执行): 标签落位后绘制短引导线
     - 在 Unicode relaxed 的 bundle 标签上启用。
     - 仅 1 格短引导,不改变主路由和端口。
  2) 渐进方案: 仅加文本前缀标记(如 [1]/[2])
     - 实现快,但会污染标签语义文本。

- 决策:
  - 执行最佳方案,因为你的诉求是“看出对应线”,不是“给标签编号”。

- 下一步:
  - 修改 `draw.ts` 让 label 绘制返回最终落点,基于该落点追加短引导线。

### 2026-02-10 02:26:00 - 短引导符增强收口

- 本轮阶段完成情况:
  - [x] 阶段1: 记录新一轮增强计划
  - [x] 阶段2: 实现标签落位返回信息
  - [x] 阶段3: 实现短引导线绘制逻辑
  - [x] 阶段4: 同步 vendor 与更新 golden
  - [x] 阶段5: 测试复现与安装验证

- 当前状态:
  - **本轮已完成** - 并线标签具备“纵向堆叠 + 短引导符”双重可读性增强。

### 2026-02-10 19:22:51 - 用户确认继续: 并线标签关联性二次优化(进行中)

- 我正在做什么,为什么:
  - 你最新反馈是“这些位置都很奇怪,看不出是哪条线”,说明第一版短引导符虽然有帮助,但在高密度交叉处仍有歧义。
  - 本轮目标是保持“标签仅上下堆叠”的硬约束不变,继续优化标签与目标线段之间的可感知关联。

- 本轮两条路线:
  1) 最佳方案(执行): 在保持纵向堆叠的前提下,让短引导符方向更稳定、长度更克制、并避免噪音字符
  2) 快速方案: 关闭引导符,退回纯堆叠标签

- 当前决策:
  - 先执行最佳方案。因为你的核心诉求是“可读性更强”,不是回退功能。

- 下一步:
  - 复现你提供的最新命令输出。
  - 逐个定位 `integration.blocked / integration.rejected / experiment.complete` 的标签归属歧义点。

### 2026-02-10 19:27:31 - 并线标签算法微调已落地(待验证)

- 已完成改动:
  - 上游 `draw.ts` 的短引导符改为“仅纵向 1 格”,移除左右 `─/-` 引导,避免文字行被横向污染。
  - `buildBundleStackedLabelLines()` 从“按输入 rank 对称偏移”改为“按真实 labelLine 偏好 y 进行稳定纵向拟合”。

- 预期收益:
  - 标签更像沿线高度自然排布,更容易看出对应关系。
  - 保持硬约束: 并线标签只上下堆叠,不左右散开。

- 下一步:
  - 同步 vendor 并复现用户图。
  - 若输出变化合理,更新 golden 并跑完整测试。

### 2026-02-10 19:33:02 - 本轮收口完成: 并线标签只上下堆叠且不再左右噪音

- 本轮阶段清单:
  - [x] 阶段1: 复现并定位标签歧义点
  - [x] 阶段2: 微调并线标签引导算法
  - [x] 阶段3: 同步 vendor 与更新 golden
  - [x] 阶段4: 运行测试与安装验证
  - [x] 阶段5: 四文件沉淀与交付

- 最终结果:
  - 并线标签维持纵向堆叠,并且同组标签统一起始列。
  - 移除了标签行内的水平引导噪音(`─/-`)。
  - 仅保留纵向短引导,避免“左右拼接”视觉误导。

- 验证结论:
  - `cargo test --test ascii_testdata unicode_testdata_matches_reference --quiet` 通过。
  - `cargo test --quiet` 通过。
  - `make install INSTALL_DIR=/Users/cuiluming/local_doc/l_dev/tool` 完成。
  - 安装后的 CLI 用用户输入复现通过。

### 2026-02-10 20:10:02 - 用户确认继续: 走线“最近侧边优先”算法优化(进行中)

- 我正在做什么,为什么:
  - 你已确认继续优化,且核心痛点转到“有些线明明左边更近却绕远路”。
  - 这属于路由代价函数与端口候选策略的问题,不改根因就会反复出现。

- 本轮两条路线:
  1) 最佳方案(执行): 改进 relaxed 路由代价,显式鼓励“贴近目标方向的近侧边”并惩罚外圈绕行
  2) 快速方案: 对个别边做后处理矫正

- 当前决策:
  - 先执行最佳方案,遵循“改良胜过新增”,不加新 CLI 参数。

- 下一步:
  - 复现并打印关键边 path,定位“为何没走左侧近路”。
  - 仅修改路由核心算法,然后回归测试。

### 2026-02-10 20:13:31 - 已完成首轮路由改动: 修复 baseFast 早退导致的近侧候选缺失

- 已做变更(上游 `edge-routing.ts`):
  - 在 `tryPickRelaxed()` 中把 `shouldProbeExpandedAllFast()` 提前并增强。
  - 当 `baseFast` 出现“侧穿/错轴/偏长”坏味道时,不再直接返回,追加 `expandedAll` FAST 探测并比较。

- 改动动机:
  - 之前 `baseFast` 一旦可达就早退,会让 `expandedAll` 中可能更贴近“最近侧边”的候选根本没有机会参加竞争。

- 下一步:
  - 同步 vendor,复现用户图。
  - 对比关键边是否仍然“明明左边近却走远”。

### 2026-02-10 20:15:14 - 第二轮加固: 近轴对穿惩罚 + 坏味道 FULL 探测

- 补充改动:
  1. 在 `nearestSidePenaltyRelaxed()` 增加“近轴对穿”重惩罚:
     - 垂直占优且近轴时,惩罚 `Left↔Right` 对穿。
     - 水平占优且近轴时,惩罚 `Up↔Down` 对穿。
  2. 在 `tryPickRelaxed()` 中,当检测到坏味道时,除了 FAST 还会额外尝试 `expandedAll + FULL`。

- 目的:
  - 解决“FAST 可达就收敛,但仍走绕路”的早收敛问题。

- 下一步:
  - 复现同一用户图,观察关键边端口与路径是否收敛到近侧。

### 2026-02-10 20:17:24 - 第三轮微调: detour 增加方向过冲惩罚

- 已做变更:
  - `detourPenaltyRelaxed()` 不再只看总 detour。
  - 新增“朝目标方向继续过冲”的额外惩罚(例如 dy<0 时 extraTop 过大)。

- 目的:
  - 压制“路径已到目标方向仍继续绕到更外侧”的大外框走线。

- 下一步:
  - 复现图对比是否仍出现左上角大框。

### 2026-02-10 20:19:05 - 第四轮微调: 并线场景优先比较 withReuse 的过冲质量

- 已做变更:
  - `pickRelaxedWithEndReuseComparison()` 增加同端点并线规则:
    - 计算 `withReuse` 与 `noReuse` 的方向过冲值;
    - 当 withReuse 过冲显著更小且代价可接受时,优先 withReuse。

- 目标:
  - 把 noReuse 导致的并线分散外绕收回到近侧共享干线。

- 下一步:
  - 复现用户图检查左上角外框是否收敛。

### 2026-02-10 20:19:40 - 进入验证阶段: 统计 golden 漂移并回归测试

- 当前观察:
  - 关键目标已达成: `Hat_experiment_integrator -> Hat_ralph` 四条边都从左侧近边入 `Hat_ralph`。
  - 仍存在左上方外框样式,属于并线可达性与复用约束共同作用的结果,本轮先以“近侧优先达成”作为收口。

- 下一步:
  - 跑 `ascii_testdata` 统计 golden 变化。
  - 更新必要 golden,再跑全量测试和安装验证。

### 2026-02-10 20:20:57 - 针对失败测试的根因修正: 并线场景优先 end reuse

- 触发问题:
  - `user_repro_case_all_edges_respect_endpoint_invariants` 失败,`integration.rejected` 路径长度=274。

- 修复动作:
  - 在 relaxed 终点段复用策略中,对“同端点并线 + Unicode”优先尝试 `tryPickRelaxed(true)`。

- 设计意图:
  - 避免 noReuse 把同端点多边硬拆开,造成大外框和超长路径。

- 下一步:
  - 先跑失败用例单测确认回落,再跑全量。

### 2026-02-10 20:26:52 - 本轮收口完成: 近侧走线优化与回归同步完成

- 本轮阶段清单:
  - [x] 阶段1: 复现并量化绕路边
  - [x] 阶段2: 调整 relaxed 路由代价与候选比较
  - [x] 阶段3: 同步 vendor 与更新 golden
  - [x] 阶段4: 执行测试与安装验证
  - [x] 阶段5: 四文件沉淀与交付

- 最终结果:
  - 用户关注的并线回边已切换到目标左侧近边进入。
  - 回归测试全部通过,安装版本已更新。

- 已确认命令:
  - `cargo test --quiet` 通过。
  - `make install INSTALL_DIR=/Users/cuiluming/local_doc/l_dev/tool` 完成。

### 2026-02-10 22:51:15 - 用户澄清需求: 纯近路优先(不偏左/右)

- 我正在做什么,为什么:
  - 你明确指出“不是左侧优先,也不是右侧优先,而是纯近路优先”。
  - 这说明当前算法里存在方向偏置惩罚,需要回收成“距离优先”的统一目标函数。

- 本轮两条路线:
  1) 最佳方案(执行): 回收方向偏置项,保留通用可读性约束,并按路径成本最小做选择
  2) 快速方案: 直接回退到旧版本

- 当前决策:
  - 执行最佳方案,避免功能回退。

- 下一步:
  - 调整 `edge-routing.ts` 的偏置惩罚和比较逻辑。
  - 复现你的图并跑全量回归。

### 2026-02-10 22:53:42 - 已完成方向偏置回收: 回到成本最小优先

- 已改动:
  - `nearestSidePenaltyRelaxed()` 删除轴向/对穿偏置,仅保留中等强度的背向惩罚。
  - `detourPenaltyRelaxed()` 删除方向过冲项,恢复方向无关的总 detour 惩罚。
  - `tryPickRelaxed()` 的 expandedAll 探测触发改为“纯路径质量条件”(绕远/拐点),不看方向。
  - `pickRelaxedWithEndReuseComparison()` 回收为纯成本比较。
  - 取消“同端点并线优先 reuse”的定向分支。

- 目标:
  - 满足“纯近路优先,上下左右都可以”。

- 下一步:
  - 同步 vendor,复现用户图并回归测试。

### 2026-02-10 22:56:39 - 本轮收口: 已切换为纯近路优先并完成验证

- 本轮阶段清单:
  - [x] 阶段1: 回收方向偏置惩罚逻辑
  - [x] 阶段2: 复现并检查近路行为
  - [x] 阶段3: 更新 vendor 与 golden
  - [x] 阶段4: 执行测试与安装验证
  - [x] 阶段5: 四文件沉淀与交付

- 结论:
  - 路由策略已回到“纯近路优先”,不固定偏左/偏右。
  - 全量测试通过,安装版本更新完成。

---

# 任务计划: continuous-learning 复盘与沉淀(2026-02-11)

## 目标
从四文件(`task_plan.md`/`notes.md`/`WORKLOG.md`/`ERRORFIX.md` + 必要的历史版本)里提炼可复用知识,并把结论固化:

- 项目级(仓库特有)的长期约定同步到 `AGENTS.md`
- 可执行的开发者范式同步到 `docs/`
- 跨项目可复用的模式提取为 `self-learning.*` skill

## 两种路线(先定,避免范围漂移)
1. 路线A(快): 只阅读当前四文件,默认不回读 `archive/**`
2. 路线B(更完整,推荐): 阅读当前四文件 + 回读与本任务直接相关的 `archive/task_plan_2026-02-09.md`

## 做出的决定
- [决定] 走路线B。
  - 理由: `archive/` 下只有 1 份直接续档的 `task_plan` 历史文件,回读成本低,但能避免遗漏关键决策与踩坑记录。

## 阶段
- [x] 阶段1: 列出四文件与历史版本
- [x] 阶段2: 阅读并产出四文件摘要
- [x] 阶段3: 去重检索 `self-learning.*` skills
- [x] 阶段4: 落盘(更新 `AGENTS.md`/`docs/` + 提取 skill)
- [x] 阶段5: 校验与收口(复查变更点,并记录到 `WORKLOG.md`)

## 状态
**已完成** - 复盘结论已同步到仓库文档与跨项目 skill,并已记录到 `WORKLOG.md`。

## 本次落盘清单(目标状态)
- `notes.md`: 追加“四文件摘要”与可复用点候选
- `AGENTS.md`: 补充长期约定(例如 `UPDATE_GOLDEN`/`validate-docs`)
- `docs/code-agent-cli.md`: 补充调试与 golden 更新范式(让 agent 可直接复用)
- `~/.codex/skills/self-learning.golden-tests-update-mode/SKILL.md`: 新增跨项目可复用 skill
- `WORKLOG.md`: 追加本次 continuous-learning 的最终产出记录

---

# 任务计划: 修复 UTF-8 截断 panic + 提升 ASCII 图可读性(2026-02-11)

## 现象
你在管道里执行:

- `printf 'flowchart ...中文注释...' | beautiful-mermaid-rs --ascii`

会触发 panic:

- `byte index 80 is not a char boundary; it is inside '意' ...`

同时,即便图能输出,当前“并线/复用干线”的走线会把多条边合并到一起,导致逻辑很难读。

## 目标
- CLI/库在遇到中文等 UTF-8 多字节字符时,不再 panic,仍然给出可用输出。
- 给用户一个明确的“禁用并线/复用”的开关,让输出更直观(牺牲紧凑度换可读性)。

## 两条路线(先定,避免范围漂移)
1. 路线A(最佳方案,推荐并执行):
   - 修复根因: 把 `[..80]` 这类按字节截断,替换为“按字符边界安全截断”工具函数。
   - 增加回归测试: 覆盖含中文注释的输入,确保不再 panic。
   - 增加/暴露一个选项: 允许关闭“边路径复用/并线”(默认保持现状,避免影响旧用例)。
2. 路线B(快速方案):
   - 仅修复 panic(安全截断),先不引入新选项与测试,快速止血。

## 当前决策
- 先走路线A,因为这是用户真实使用场景,没有回归测试很容易再次踩到。

## 阶段
- [ ] 阶段1: 复现 panic 并定位代码
- [ ] 阶段2: 实现 UTF-8 安全截断并补测试
- [ ] 阶段3: 设计并线开关并落地到 CLI/API
- [ ] 阶段4: 跑全量测试与本地复现验证
- [ ] 阶段5: 四文件沉淀与交付

## 状态
**目前在阶段1** - 复现 panic,并定位 `crates/tirith-core/src/audit.rs:99` 的不安全截断点。

### 2026-02-11 08:18:51 - 阶段推进: 明确 panic 来源 + 落地 routing 开关并完成回归

- 阶段1结论(复现与定位):
  - 在本仓库直接运行 `printf '...中文...' | cargo run -- --ascii` 不会 panic。
  - 因此你看到的 panic 更像来自外部项目 `tirith-core` 的审计/日志截断代码(按字节切 `[..80]`)。
  - 我尝试在本机按路径搜索 `*/crates/tirith-core/src/audit.rs`,暂未定位到该文件,因此无法直接在此仓库内落盘修复。

- 阶段3完成(可读性开关):
  - JS bundle 已支持 `routing: strict|relaxed`。
  - 本仓库已把该开关对外暴露到 Rust API 与 CLI: `beautiful-mermaid-rs --ascii --routing strict|relaxed`。
  - 这样你可以对同一份 Mermaid 直接对照两种走线策略,选择更“读得懂”的那一个。

- 验证:
  - `cargo test` 全量通过。

- 阶段清单(更新版):
  - [x] 阶段1: 复现 panic 并定位代码(定位到外部 `tirith-core` 截断逻辑)
  - [x] 阶段2: 输出 UTF-8 安全截断的修复建议(见 notes/交付说明)
  - [x] 阶段3: 落地 routing 开关到 CLI/API
  - [x] 阶段4: 跑全量测试与本地对照验证
  - [ ] 阶段5: 四文件沉淀与交付(进行中)

## 状态
**目前在阶段5** - 追加记录到 `notes.md`/`WORKLOG.md`/`ERRORFIX.md`,并给出可直接复制使用的命令与修复片段。

### 2026-02-11 08:21:25 - 阶段5完成: 四文件落盘并收口

- 已落盘:
  - `notes.md`: 追加 routing 事实来源 + UTF-8 截断 panic 的修复片段。
  - `WORKLOG.md`: 追加本次变更记录(文件/用法/验证)。
  - `task_plan.md`: 更新阶段推进与结论。

- 收口结论:
  - 本仓库已支持 `--routing strict|relaxed` 用于对照输出差异,缓解“并线难读”的问题。
  - 你贴出来的 panic 不在本仓库内,需要在触发 panic 的外部项目里修复 UTF-8 截断(建议片段已给出)。

## 状态
**已完成** - routing 开关已落地并通过回归,四文件已记录,可进入下一轮“按图优化可读性”的迭代。
